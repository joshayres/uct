fn a(int a, int b, int c): int, char
{
}

struct a
{
    foo: i32;
    bar: f32;
}

enum a
{
}

//Basically an enum but each err value is unique from err type to err type
//err vals are a type u16 and are greater than 0
err a
{
}

i64/u64
i32/u32
i16/u16
i8/u8
f32/f64

let foo: i32 = 10;

const foo: i32 = 1324;

let foo: [i32; 5] = [1, 2, 3, 4, 5];
let 2dfoo: [[i32; 5]; 6];

let foo: i32 = 423;
let a: ^i32 = &foo;
let b := a^;
assert(b == foo);

let foo: f32 = 10.4;
let bar: i32 = (i32)foo;

if(a)
{
}

for, while

for(i: i32; i < 1; ++i)
{}

let foo: [i32; 5] = [1, 2, 3, 4, 5];

//Works on arrays/vectors or something that is null terminated ie \0
for(bar in foo)
{
    assert(typeof(bar) == i32);
}

while(bool)
{}

enum foo
{
    yes;
    no;
    maybe;
}

let type: foo = foo.yes;

switch(type)
{
    foo.yes:
        hoafh;
    foo.no:
        ghoqa;
        break;
    foo.maybe:
        ahjslk;
}

switch(type)
{
    foo.yes => agoui;
    foo.no => agohf;
    foo.maybe => afkghu;
    _ => hgald;
}

//HOPEFUL TODOS:
zipped packages
package manager

//file 1
pack blah;

exter fn a()
{
    b();
}

fn b()
{
}

//file 2
import blah

a();
b(); <- this one would error as b is not defined


//Maybe Hopeful todo:
Generics
Macros
Overloading

for functions have a lookup table for their keywords unless stated otherwise
